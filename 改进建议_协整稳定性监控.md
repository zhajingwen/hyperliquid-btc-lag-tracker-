# åæ•´ç¨³å®šæ€§ç›‘æ§æ”¹è¿›å»ºè®®

## é—®é¢˜è¯Šæ–­

å½“å‰å®ç°ï¼š
```python
# é™æ€åæ•´æ£€éªŒï¼ˆå½¢æˆæœŸï¼‰
åæ•´æ£€éªŒ(å…¨æ ·æœ¬) â†’ is_cointegrated â†’ å¼€å§‹äº¤æ˜“
```

å­˜åœ¨é£é™©ï¼š
- âŒ äº¤æ˜“æœŸé—´åæ•´å…³ç³»å¯èƒ½æ–­è£‚
- âŒ æ— æ³•åŠæ—¶å‘ç°Î²æ¼‚ç§»
- âŒ "ç ´äº†"æ‰å‘ç°ï¼ŒæŸå¤±å·²é€ æˆ

---

## è§£å†³æ–¹æ¡ˆï¼šä¸‰å±‚ç¨³å®šæ€§ç›‘æ§

### ç¬¬1å±‚ï¼šå½¢æˆæœŸæ£€éªŒï¼ˆå·²å®ç°âœ…ï¼‰

```python
# ç°æœ‰ä»£ç ï¼šhyperliquid_analyzer.py
stationarity_level, p_value = _check_spread_stationarity(spread)
if not stationarity_level.is_valid:
    # ä¸è¿›å…¥äº¤æ˜“
```

**ä¿ç•™ç°çŠ¶**ï¼Œæ— éœ€ä¿®æ”¹ã€‚

---

### ç¬¬2å±‚ï¼šäº¤æ˜“æœŸRollingæ£€éªŒï¼ˆæ–°å¢ğŸ”¥ï¼‰

#### 2.1 æ»šåŠ¨ADFæ£€éªŒ

```python
def _monitor_cointegration_stability(
    self,
    btc_prices: pd.Series,
    alt_prices: pd.Series,
    beta: float,
    window: int = 30,  # æ»šåŠ¨çª—å£ï¼š150åˆ†é’Ÿï¼ˆ5mæ•°æ®ï¼‰
    step: int = 5      # æ¯25åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
) -> dict:
    """
    æ»šåŠ¨ç›‘æ§åæ•´ç¨³å®šæ€§

    Returns:
        {
            'is_stable': bool,           # æ˜¯å¦ç¨³å®š
            'p_values': list,            # på€¼åºåˆ—
            'break_detected': bool,      # æ˜¯å¦æ£€æµ‹åˆ°ç»“æ„æ–­è£‚
            'break_time': int | None,    # æ–­è£‚æ—¶é—´ç´¢å¼•
            'half_life': float | None    # å‡å€¼å›å½’åŠè¡°æœŸ
        }
    """

    results = {
        'is_stable': True,
        'p_values': [],
        'break_detected': False,
        'break_time': None,
        'half_life': None
    }

    # 1. æ»šåŠ¨ADFæ£€éªŒ
    for i in range(window, len(btc_prices), step):
        # è®¡ç®—å±€éƒ¨ä»·å·®
        log_btc = np.log(btc_prices.iloc[i-window:i])
        log_alt = np.log(alt_prices.iloc[i-window:i])
        spread = log_alt - beta * log_btc

        # ADFæ£€éªŒ
        adf_result = adfuller(spread, autolag='AIC')
        p_value = adf_result[1]
        results['p_values'].append(p_value)

        # æ£€æµ‹æ–­è£‚ï¼ˆè¿ç»­3æ¬¡p>0.10ï¼‰
        if len(results['p_values']) >= 3:
            recent_p = results['p_values'][-3:]
            if all(p > 0.10 for p in recent_p):
                results['is_stable'] = False
                results['break_detected'] = True
                results['break_time'] = i
                logger.warning(f"åæ•´å…³ç³»æ–­è£‚æ£€æµ‹ï¼šç¬¬{i}ä¸ªæ•°æ®ç‚¹ï¼Œpå€¼={p_value:.4f}")
                break

    # 2. è®¡ç®—åŠè¡°æœŸï¼ˆAR(1)æ¨¡å‹ï¼‰
    if results['is_stable']:
        spread = np.log(alt_prices) - beta * np.log(btc_prices)
        spread_diff = spread.diff().dropna()
        spread_lag = spread.shift(1).dropna()

        # ç¡®ä¿ç´¢å¼•å¯¹é½
        common_idx = spread_diff.index.intersection(spread_lag.index)
        spread_diff = spread_diff.loc[common_idx]
        spread_lag = spread_lag.loc[common_idx]

        # AR(1): Î”spread = Î± + Î¸Â·spread_{t-1}
        model = LinearRegression()
        model.fit(spread_lag.values.reshape(-1, 1), spread_diff.values)
        theta = model.coef_[0]

        if theta < 0:  # ç¡®ä¿æ˜¯å‡å€¼å›å½’
            half_life = -np.log(2) / np.log(1 + theta)
            results['half_life'] = half_life

            # åŠè¡°æœŸè¿‡é•¿è­¦å‘Šï¼ˆ>24å°æ—¶ = 288ä¸ª5åˆ†é’ŸKçº¿ï¼‰
            if half_life > 288:
                logger.warning(f"å‡å€¼å›å½’åŠè¡°æœŸè¿‡é•¿ï¼š{half_life:.1f}ä¸ªå‘¨æœŸï¼ˆ{half_life*5/60:.1f}å°æ—¶ï¼‰")

    return results
```

#### 2.2 CUSUMæ£€éªŒï¼ˆç»“æ„æ–­è£‚æ£€æµ‹ï¼‰

```python
def _detect_structural_break(self, spread: pd.Series) -> dict:
    """
    CUSUMæ£€éªŒæ£€æµ‹åæ•´å…³ç³»çš„ç»“æ„æ–­è£‚

    Returns:
        {
            'has_break': bool,
            'break_point': int | None,
            'cusum_stat': float
        }
    """
    from statsmodels.stats.diagnostic import breaks_cusumolsresq

    # ç®€åŒ–ç‰ˆï¼šåŸºäºæ®‹å·®çš„ç´¯ç§¯å’Œ
    spread_resid = spread - spread.mean()
    cusum = np.cumsum(spread_resid) / spread.std()

    # æ£€æµ‹æ˜¯å¦è¶…å‡ºè¾¹ç•Œï¼ˆÂ±0.948 * sqrt(T) ä¸º5%æ˜¾è‘—æ€§æ°´å¹³ï¼‰
    T = len(cusum)
    threshold = 0.948 * np.sqrt(T)

    has_break = (np.abs(cusum) > threshold).any()
    break_point = np.argmax(np.abs(cusum) > threshold) if has_break else None

    return {
        'has_break': has_break,
        'break_point': break_point,
        'cusum_stat': np.max(np.abs(cusum))
    }
```

---

### ç¬¬3å±‚ï¼šBetaæ¼‚ç§»ç›‘æ§ï¼ˆæ–°å¢ğŸ”¥ï¼‰

#### 3.1 æ»šåŠ¨Betaæ ‡å‡†å·®

```python
def _monitor_beta_drift(
    self,
    btc_prices: pd.Series,
    alt_prices: pd.Series,
    window: int = 100,  # Betaè®¡ç®—çª—å£
    roll_periods: int = 10  # è®¡ç®—æœ€è¿‘10ä¸ªBeta
) -> dict:
    """
    ç›‘æ§Betaç³»æ•°çš„æ¼‚ç§»ç¨‹åº¦

    Returns:
        {
            'current_beta': float,
            'beta_std': float,          # æœ€è¿‘NæœŸBetaçš„æ ‡å‡†å·®
            'beta_cv': float,           # å˜å¼‚ç³»æ•°ï¼ˆCV = std/meanï¼‰
            'is_drifting': bool         # æ˜¯å¦æ­£åœ¨æ¼‚ç§»
        }
    """

    betas = []
    for i in range(window, len(btc_prices), window // roll_periods):
        if i + window > len(btc_prices):
            break

        beta = self._calculate_beta_from_prices(
            btc_prices.iloc[i:i+window],
            alt_prices.iloc[i:i+window]
        )
        if beta is not None:
            betas.append(beta)

    if len(betas) < 3:
        return {'current_beta': None, 'beta_std': None, 'beta_cv': None, 'is_drifting': False}

    current_beta = betas[-1]
    beta_std = np.std(betas)
    beta_cv = beta_std / abs(np.mean(betas))

    # åˆ¤æ–­æ¼‚ç§»ï¼ˆCV > 0.15 è®¤ä¸ºä¸ç¨³å®šï¼‰
    is_drifting = beta_cv > 0.15

    if is_drifting:
        logger.warning(f"Betaæ¼‚ç§»æ£€æµ‹ï¼šCV={beta_cv:.3f}, è¿‘æœŸBeta={betas[-3:]}")

    return {
        'current_beta': current_beta,
        'beta_std': beta_std,
        'beta_cv': beta_cv,
        'is_drifting': is_drifting
    }
```

---

## é›†æˆåˆ°ç°æœ‰ä»£ç 

### ä¿®æ”¹ä½ç½®ï¼š`hyperliquid_analyzer.py`

#### æ­¥éª¤1ï¼šæ‰©å±•`find_optimal_delay`æ–¹æ³•

```python
@staticmethod
def find_optimal_delay(
    btc_ret: np.ndarray,
    alt_ret: np.ndarray,
    max_lag: int = 3,
    enable_outlier_treatment: bool = True,
    enable_beta_calc: bool = True,
    enable_stability_monitoring: bool = True,  # âœ¨ æ–°å¢å‚æ•°
    **kwargs
) -> dict:
    """
    ä¼˜åŒ–å»¶è¿Ÿæ£€æµ‹ï¼ˆå¢å¼ºç‰ˆï¼‰

    Returns:
        {
            'tau_star': int,
            'correlations': list,
            'max_corr': float,
            'beta': float,

            # âœ¨ æ–°å¢ç¨³å®šæ€§ç›‘æ§ç»“æœ
            'stability': {
                'is_stable': bool,
                'half_life': float,
                'beta_cv': float,
                'break_detected': bool
            }
        }
    """

    # ... ç°æœ‰ä»£ç  ...

    # ========== æ–°å¢ï¼šç¨³å®šæ€§ç›‘æ§ ==========
    if enable_stability_monitoring and len(btc_ret) > 100:
        # éœ€è¦ä»·æ ¼åºåˆ—ï¼ˆä»æ”¶ç›Šç‡é‡æ„æˆ–ç›´æ¥ä¼ å…¥ï¼‰
        btc_prices = kwargs.get('btc_prices')
        alt_prices = kwargs.get('alt_prices')

        if btc_prices is not None and alt_prices is not None:
            # æ»šåŠ¨åæ•´æ£€éªŒ
            coint_stability = DelayCorrelationAnalyzer._monitor_cointegration_stability(
                btc_prices, alt_prices, beta=result['beta']
            )

            # Betaæ¼‚ç§»ç›‘æ§
            beta_stability = DelayCorrelationAnalyzer._monitor_beta_drift(
                btc_prices, alt_prices
            )

            # æ±‡æ€»ç¨³å®šæ€§ç»“æœ
            result['stability'] = {
                'is_stable': coint_stability['is_stable'] and not beta_stability['is_drifting'],
                'half_life': coint_stability['half_life'],
                'beta_cv': beta_stability['beta_cv'],
                'break_detected': coint_stability['break_detected']
            }

    return result
```

#### æ­¥éª¤2ï¼šä¿®æ”¹é£ä¹¦å‘Šè­¦ï¼ˆæ·»åŠ ç¨³å®šæ€§æŒ‡æ ‡ï¼‰

```python
def _output_results(self, results: dict, exchange_name: str, coin: str):
    """å¢å¼ºç‰ˆè¾“å‡ºï¼ˆåŒ…å«ç¨³å®šæ€§ç›‘æ§ï¼‰"""

    # ... ç°æœ‰è¾“å‡º ...

    # ========== æ–°å¢ï¼šç¨³å®šæ€§ç›‘æ§å‘Šè­¦ ==========
    if 'stability' in results:
        stability = results['stability']

        message += f"\n\nğŸ“Š ç¨³å®šæ€§ç›‘æ§\n"
        message += f"  åæ•´ç¨³å®š: {'âœ… æ˜¯' if stability['is_stable'] else 'âŒ å¦'}\n"

        if stability['half_life']:
            message += f"  åŠè¡°æœŸ: {stability['half_life']:.1f}æœŸ ({stability['half_life']*5/60:.1f}å°æ—¶)\n"

        if stability['beta_cv']:
            message += f"  Betaæ³¢åŠ¨: {stability['beta_cv']*100:.1f}%\n"

        if stability['break_detected']:
            message += f"  âš ï¸ è­¦å‘Šï¼šæ£€æµ‹åˆ°åæ•´å…³ç³»æ–­è£‚\n"

    # å‘é€å‘Šè­¦
    sender.send(message, at_all=False)
```

---

## ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šåˆ†ææ—¶å¯ç”¨ç¨³å®šæ€§ç›‘æ§

```python
analyzer = DelayCorrelationAnalyzer(exchange_name="hyperliquid")

results = analyzer.find_optimal_delay(
    btc_ret=btc_returns,
    alt_ret=alt_returns,
    enable_stability_monitoring=True,  # å¯ç”¨ç›‘æ§
    btc_prices=btc_prices,             # å¿…é¡»ä¼ å…¥ä»·æ ¼åºåˆ—
    alt_prices=alt_prices
)

# æ£€æŸ¥ç¨³å®šæ€§
if not results['stability']['is_stable']:
    logger.warning("åæ•´å…³ç³»ä¸ç¨³å®šï¼Œä¸å»ºè®®äº¤æ˜“")
```

### ç¤ºä¾‹2ï¼šäº¤æ˜“æœŸé—´å®æ—¶ç›‘æ§

```python
# åœ¨äº¤æ˜“å¾ªç¯ä¸­
while is_trading:
    # è·å–æœ€æ–°æ•°æ®
    latest_btc = fetch_latest_prices('BTCUSDT', periods=200)
    latest_alt = fetch_latest_prices(f'{coin}USDT', periods=200)

    # æ£€æŸ¥ç¨³å®šæ€§
    stability = analyzer._monitor_cointegration_stability(
        latest_btc, latest_alt, beta=current_beta
    )

    if stability['break_detected']:
        logger.critical("åæ•´å…³ç³»æ–­è£‚ï¼Œç«‹å³å¹³ä»“ï¼")
        close_position(coin)
        break

    # æ£€æŸ¥åŠè¡°æœŸ
    if stability['half_life'] and stability['half_life'] > 288:  # >24å°æ—¶
        logger.warning("å‡å€¼å›å½’é€Ÿåº¦è¿‡æ…¢ï¼Œè€ƒè™‘å‡ä»“")
```

---

## æ€§èƒ½å½±å“è¯„ä¼°

### è®¡ç®—æˆæœ¬

```python
# åŸæœ‰é€»è¾‘
é™æ€åæ•´æ£€éªŒï¼š1æ¬¡ADFï¼ˆ~10msï¼‰

# æ–°å¢é€»è¾‘
æ»šåŠ¨ADFæ£€éªŒï¼šæ¯5ä¸ªç‚¹1æ¬¡ï¼Œå…±200/5=40æ¬¡ï¼ˆ~400msï¼‰
CUSUMæ£€éªŒï¼š1æ¬¡ï¼ˆ~5msï¼‰
Betaæ¼‚ç§»ç›‘æ§ï¼šè®¡ç®—10ä¸ªæ»šåŠ¨Betaï¼ˆ~100msï¼‰

æ€»è®¡å¢åŠ ï¼š~500ms/å¸ç§
```

**å¯¹äºå®æ—¶äº¤æ˜“**ï¼š
- ç›‘æ§5ä¸ªå¸ç§ï¼š2.5ç§’ï¼ˆå¯æ¥å—ï¼‰
- å»ºè®®æ¯5-10åˆ†é’Ÿè¿è¡Œä¸€æ¬¡ç¨³å®šæ€§æ£€æŸ¥

---

## å®æ–½ä¼˜å…ˆçº§

### P0ï¼ˆç«‹å³å®æ–½ï¼‰
- âœ… æ»šåŠ¨ADFæ£€éªŒ
- âœ… åŠè¡°æœŸè®¡ç®—
- âœ… Betaæ¼‚ç§»ç›‘æ§ï¼ˆCVæŒ‡æ ‡ï¼‰

### P1ï¼ˆä¸‹ä¸ªç‰ˆæœ¬ï¼‰
- â³ CUSUMæ£€éªŒï¼ˆç»“æ„æ–­è£‚ï¼‰
- â³ Chow testï¼ˆæ–­ç‚¹æ£€éªŒï¼‰

### P2ï¼ˆå¯é€‰ï¼‰
- ğŸ”® Kalman Filterï¼ˆåŠ¨æ€Betaä¼°è®¡ï¼‰
- ğŸ”® DCC-GARCHï¼ˆåŠ¨æ€ç›¸å…³æ€§ï¼‰

---

## éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶
- [ ] æ»šåŠ¨ADFèƒ½æ£€æµ‹åˆ°åæ•´å…³ç³»æ–­è£‚
- [ ] åŠè¡°æœŸè®¡ç®—ç»“æœåˆç†ï¼ˆ5-50å°æ—¶ï¼‰
- [ ] Beta CVèƒ½åæ˜ å™äº‹åˆ‡æ¢ï¼ˆå¦‚DeFi â†’ AIï¼‰

### æ€§èƒ½éªŒæ”¶
- [ ] å•å¸ç§ç¨³å®šæ€§æ£€æŸ¥ <500ms
- [ ] ä¸å½±å“ç°æœ‰åˆ†ææµç¨‹
- [ ] å†…å­˜å ç”¨å¢åŠ  <50MB

### å›æµ‹éªŒè¯
- [ ] åœ¨å†å²æ•°æ®ä¸­èƒ½æå‰æ£€æµ‹åˆ°å¤±æ•ˆæ¡ˆä¾‹
- [ ] ç¨³å®šæ€§è¿‡æ»¤åç­–ç•¥å¤æ™®æ¯”ç‡æå‡ >10%

---

## å‚è€ƒæ–‡çŒ®

1. **Gregory, A. W., & Hansen, B. E. (1996)**. "Residual-based tests for cointegration in models with regime shifts." Journal of Econometrics, 70(1), 99-126.

2. **Pascual, L., Romo, J., & Ruiz, E. (2006)**. "Bootstrap prediction for returns and volatilities in GARCH models." Computational Statistics & Data Analysis, 50(9), 2293-2312.

3. **Zivot, E., & Andrews, D. W. K. (1992)**. "Further evidence on the great crash, the oil-price shock, and the unit-root hypothesis." Journal of Business & Economic Statistics, 10(3), 251-270.

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-12-29
**çŠ¶æ€**: å¾…å®æ–½
